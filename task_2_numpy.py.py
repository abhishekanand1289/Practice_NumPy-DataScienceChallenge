# -*- coding: utf-8 -*-
"""Copy of session-14-task.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DqkaIp0T_2Z8I66L7NxKYkhGZ_MYuuo4

###`Q-1:` Find the nearest element in the array to a given integer.
```
Ex:-
a=23 and array - [10 17 24 31 38 45 52 59].
Nearest element is 24
```
Hint: Read about this function `argmin()`
"""

import numpy as np
arr = np.array([10,17,24,31,38,45,52,59])
a = 60
arr[np.argmin(abs(arr-a))]

"""###`Q-2:` Replace multiples of 3 or 5 as 0 in the given array.
```
arr=[1 2 3 4 5 6 7 9]

result-> [1 2 0 4 0 0 7 0]
```
"""

arr=np.array([1,2,3,4,5,6,7,9])
arr[(arr%3==0) | (arr%5==0)] = 0
arr

"""###`Q-3:` Use Fancy Indexing.
1. Double the array elements at  given indexes
```
arr = np.arrange(10)
indexes = [0,3,4,9]
```
Result -> `[ 0  1  2  6  8  5  6  7  8 18]`

2. Using a given array make a different array as in below example
```
array = [1,2,3]
result array -> [1 1 1 2 2 2 3 3 3]
```
* Internal-repetion should be as length of the array.

Hint:
```
if a is an array
a = [2,4]
a[[1,1,0,1]] will result in-> [4 4 2 4]
```
"""

arr = np.arange(10)
arr[[0,3,4,9]]*=2
arr

array = np.array([1,2,3])

repetitions = []

for i in range(len(array)):
  repetitions.extend([i]*len(array))

array[repetitions]

"""###`Q-4:` Your are given an array which is havig some nan value. You job is to fill those nan values with most common element in the array.
```
arr=np.array([[1,2,np.nan],[4,2,6],[np.nan,np.nan,5]])

```
"""

arr=np.array([[1,2,np.nan],[4,2,6],[np.nan,np.nan,5]])
unique_elements, counts = np.unique(arr, return_counts=True)
common_element = unique_elements[counts>1]
arr[np.isnan(arr)] = common_element[0]
arr

"""### `Q-5:` Write a NumPy program

- to find the missing data in a given array. Return a boolean matrix.
- also try to fill those missing values with 0. For that, you can use `np.nan_to_num(a)`

```python
import numpy as np

np.array([[3, 2, np.nan, 1],
          [10, 12, 10, 9],
          [5, np.nan, 1, np.nan]])
```
"""

a = np.array([[3, 2, np.nan, 1],
          [10, 12, 10, 9],
          [5, np.nan, 1, np.nan]])

print(np.isnan(a))
np.nan_to_num(a,0)

"""###`Q-6:` Given two arrays, X and Y, construct the Cauchy matrix C.
`Cij =1/(xi - yj)`

http://en.wikipedia.org/wiki/Cauchy_matrix
```
x = numpy.array([1,2,3,4]).reshape((-1, 1)
y = numpy.array([5,6,7])
```
"""

x = np.array([1,2,3,4]).reshape((-1, 1))
y = np.array([5,6,7])
print(x)
print(y)
1/(x-y)

"""###`Q-7:` Plot this below equation.

$$\large y = \frac{e^x - e^{-x}}{e^x + e^{-x}}$$

**Note: This equation is called tanh activation function. In deep learning, many times this function is used. If you find some difference between the sigmoid function and this tanh function, note that to your notebook.**
"""

import matplotlib.pyplot as plt
x = np.linspace(-10,10)
y = ((np.exp(x))-(np.exp(-x)))/((np.exp(x)+(np.exp(-x))))

plt.plot(x,y)

"""### `Q-8:` Plot the below equation.

$$\large y = \sqrt{36 - (x - 4)^2} + 2$$

The range of x should be between -2 to 10. $x âˆˆ [-2, 10]$


"""

x = np.linspace(-2,10)
y = np.sqrt(36-((x-4)**2)+2)

plt.plot(x,y)

"""### `Q-9:` Write a program implement Boradcasting Rule to check if two array can be added or not.
Given tuples of shapes.
```
shape of a- (3,2,2)
shape of b- (2,2)

check_broadcast(a, b) -> return Boolean (True if can broadcasted, False other wise.)
```
"""

a = np.arange(12).reshape(3,2,2)
b = np.arange(6).reshape(3,2,1)

def check_broadcast(a, b):
  a = np.shape(a)[::-1]
  b = np.shape(b)[::-1]
  for i,j in zip(a,b):
    if i!=j and i!=1 and j!=1:
      return False
    return True

check_broadcast(a,b)

